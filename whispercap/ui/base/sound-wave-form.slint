import { Theme } from "../theme.slint";
import { Util } from "../panel/def.slint";
import { Label } from "label.slint";

// Example:
// SoundWaveForm {
//     width: Math.min(1000px, root.width * 0.8);
//     wave-data: noise-data;
//     wave-color: Theme.warning-color;
//     show-timestamp: true;
//     start-timestamp: "01:00";
//     end-timestamp: "05:00";
// }

export component SoundWaveForm inherits Rectangle {
    in-out property <[float]> wave-data;
    in-out property <float> zoom-level: 1.0;
    in-out property <float> amplitude-scale: 1.0;
    in-out property <length> data-width: 2px;
    in-out property <color> wave-color: Theme.brand-color;
    in-out property <bool> is-mono;
    in-out property <bool> show-control-handle: true;
    in-out property <color> center-line-color: Theme.have-read-text-color;
    in-out property <color> start-control-handle-color: Theme.success-color;
    in-out property <color> end-control-handle-color: Theme.danger-color;
    in-out property <length> control-handle-size: Theme.icon-size * 0.8;
    in-out property <string> start-timestamp: "00:00";
    in-out property <string> end-timestamp: "00:00";
    in-out property <color> timestamp-color: Theme.regular-text-color;
    in-out property <bool> show-timestamp;
    in-out property <bool> disable-zoom;
    in-out property <bool> disable-amplitude;

    private property <length> max-data-width: 16px;
    private property <length> horizontal-offset: 0px;
    private property <bool> reset-control-handle-pos-flag;
    private property <length> start-control-handle-pos-cache: control-handle-size / -2;
    private property <length> end-control-handle-pos-cache: root.width - control-handle-size / 2;
    private property <[float]> final-wave-data: Util.cal-sound-wave(root.wave-data, clamp(root.width / 1px, 1, max-data-width / 1px), root.data-width / 1px, self.is-mono);

    changed final-wave-data => {
        horizontal-offset = 0px;
        zoom-level = 1.0;
    }

    callback moved(percent: float); // move left: > 0; move right: < 0;
    callback zoom-changed(level: float);
    callback amplitude-changed(scale: float);
    callback start-position-changed(position: float); // [0, 1]
    callback end-position-changed(position: float); // [0, 1]

    public function reset-view() {
        zoom-level = 1.0;
        amplitude-scale = 1.0;
        horizontal-offset = 0px;
    }

    public function reset-control-handle-pos() {
        reset-control-handle-pos-flag = !reset-control-handle-pos-flag;
    }

    width: wave-data.length * 2px;
    height: Theme.default-font-size * 10;
    background: Theme.secondary-background;
    border-width: Theme.default-border-width;
    border-color: Theme.base-border-color;
    border-radius: Theme.border-radius;

    Rectangle {
        clip: true;

        if is-mono: Rectangle {
            for data[data-index] in final-wave-data: Rectangle {
                x: (data-index / Math.max(1, final-wave-data.length)) * parent.width * zoom-level + horizontal-offset;
                y: parent.height - self.height;
                width: Math.clamp((parent.width * zoom-level / Math.max(1, final-wave-data.length)), 1px, max-data-width);
                height: Math.abs(data) * parent.height * amplitude-scale;
                background: wave-color;
            }
        }

        if !is-mono: Rectangle {
            private property <int> frame-counts: final-wave-data.length / 2;

            for data[index] in final-wave-data: Rectangle {
                if mod(index, 2) == 0: Rectangle {
                    private property <int> data-index: 0;

                    init => {
                        data-index = index / 2;
                    }

                    x: (data-index / Math.max(1, frame-counts)) * parent.width * zoom-level + horizontal-offset;
                    y: data >= 0 ? (parent.height / 2 - self.height) : (parent.height / 2);
                    width: Math.clamp((parent.width * zoom-level / Math.max(1, frame-counts)), 1px, max-data-width);
                    height: Math.abs(data) * parent.height / 2 * amplitude-scale;
                    background: wave-color;
                }

                if mod(index, 2) == 1: Rectangle {
                    private property <int> data-index: 0;

                    init => {
                        data-index = index / 2;
                    }

                    x: (data-index / Math.max(1, frame-counts)) * parent.width * zoom-level + horizontal-offset;
                    y: data >= 0 ? (parent.height / 2 - self.height) : (parent.height / 2);
                    width: Math.clamp((parent.width * zoom-level / Math.max(1, frame-counts)), 1px, max-data-width);
                    height: Math.abs(data) * parent.height / 2 * amplitude-scale;
                    background: wave-color;
                }
            }
        }
    }

    HorizontalLayout {
        padding-left: show-timestamp ? Theme.padding : 0;
        padding-right: show-timestamp ? Theme.padding : 0;
        spacing: Theme.spacing;
        width: root.width;

        private property <length> center-line-width: root.width - self.padding-left - self.padding-right - self.spacing * 2;

        if show-timestamp: Label {
            init => {
                center-line-width -= self.preferred-width;
            }

            text: start-timestamp;
            color: timestamp-color;
        }

        center-line := Rectangle {
            y: parent.height / 2 - self.height / 2;
            width: !show-timestamp ? root.width : center-line-width;
            height: Theme.default-border-width;
            background: root.center-line-color;
            opacity: is-mono ? 0.3 : 1;
        }

        if show-timestamp: Label {
            init => {
                center-line-width -= self.preferred-width;
            }

            text: end-timestamp;
            color: timestamp-color;
        }
    }

    TouchArea {
        mouse-cursor: self.pressed ? MouseCursor.grabbing : MouseCursor.grab;

        property <length> start-drag-x: 0px;
        property <length> start-offset: 0px;
        property <bool> is-dragging: false;

        changed pressed => {
            is-dragging = false;
            if (!self.pressed) {
                root.moved((start-drag-x - self.mouse-x) / root.width);
            }
        }

        moved => {
            if (self.pressed) {
                if (!is-dragging) {
                    start-offset = horizontal-offset;
                    start-drag-x = self.mouse-x;
                    is-dragging = true;
                }
                horizontal-offset = start-offset - (start-drag-x - self.mouse-x);
            }
        }

        scroll-event(event) => {
            if (event.modifiers.control) {
                if (!disable-amplitude) {
                    if (event.delta-y > 0) {
                        amplitude-scale += 0.1;
                        amplitude-changed(amplitude-scale);
                        return EventResult.accept;
                    } else if (event.delta-y < 0) {
                        amplitude-scale = max(0, amplitude-scale - 0.1);
                        amplitude-changed(amplitude-scale);
                        return EventResult.accept;
                    }
                }
            } else {
                if (!disable-zoom) {
                    if (event.delta-y > 0) {
                        zoom-level += 0.1;
                        zoom-changed(zoom-level);
                        return EventResult.accept;
                    } else if (event.delta-y < 0) {
                        zoom-level = max(0, zoom-level - 0.1);
                        zoom-changed(zoom-level);
                        return EventResult.accept;
                    }
                }
            }
            return EventResult.reject;
        }
    }

    if show-control-handle: Rectangle {
        x: control-handle-size / -2;
        y: control-handle-size / -2;
        width: control-handle-size;
        height: root.height;

        private property reset-pos-flag <=> reset-control-handle-pos-flag;

        changed reset-pos-flag => {
            self.x = control-handle-size / -2;
            root.start-control-handle-pos-cache = self.x;
        }

        start-rec := Rectangle {
            y: 0;
            width: control-handle-size;
            height: self.width;
            border-radius: self.width / 2;
            background: start-control-handle-color;
        }

        Rectangle {
            x: start-rec.x + control-handle-size / 2;
            y: control-handle-size / 2;
            width: Theme.default-border-width * 2;
            height: root.height;
            background: start-control-handle-color;
        }

        TouchArea {
            mouse-cursor: MouseCursor.move;

            changed pressed => {
                if (!self.pressed) {
                    start-position-changed((parent.x + control-handle-size) / root.width);
                }
            }

            moved => {
                if (self.pressed) {
                    parent.x = min(clamp(parent.x + self.mouse-x - self.pressed-x, - control-handle-size / 2, root.width - control-handle-size / 2), root.end-control-handle-pos-cache - control-handle-size);

                    root.start-control-handle-pos-cache = parent.x;
                }
            }
        }
    }

    if show-control-handle: Rectangle {
        x: root.width - control-handle-size / 2;
        y: control-handle-size / -2;
        width: control-handle-size;
        height: root.height;

        private property reset-pos-flag <=> reset-control-handle-pos-flag;

        changed reset-pos-flag => {
            self.x = root.width - control-handle-size / 2;
            root.end-control-handle-pos-cache = self.x;
        }

        end-rec := Rectangle {
            y: 0;
            width: control-handle-size;
            height: self.width;
            border-radius: self.width / 2;
            background: end-control-handle-color;
        }

        Rectangle {
            x: end-rec.x + control-handle-size / 2;
            y: control-handle-size / 2;
            width: Theme.default-border-width * 2;
            height: root.height;
            background: end-control-handle-color;
        }

        TouchArea {
            mouse-cursor: MouseCursor.move;

            changed pressed => {
                if (!self.pressed) {
                    end-position-changed((parent.x + control-handle-size) / root.width);
                }
            }

            moved => {
                if (self.pressed) {
                    parent.x = max(clamp(parent.x + self.mouse-x - self.pressed-x, - control-handle-size / 2, root.width - control-handle-size / 2), root.start-control-handle-pos-cache + control-handle-size);

                    root.end-control-handle-pos-cache = parent.x;
                }
            }
        }
    }
}
